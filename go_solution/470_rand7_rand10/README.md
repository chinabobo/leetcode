https://leetcode.cn/problems/implement-rand10-using-rand7/

已有方法 Rand7() 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 Rand10() 生成 1 到 10 范围内的均匀随机整数。

思路
我们可以将 Rand7() 视作一个 7 进制位的生成器。由于 Rand7() 的结果范围是 [1, 7]，故我们取 Rand7() - 1 作为对应的 7 进制位。每执行 k
次 Rand7()，将得到一个 k 位的 7 进制整数，在 [0,7^k−1]范围内均匀分布。
也就是说，我们执行两次Rand7(),就可以得到[0,48]的均匀整数。
```go
for {
    x := (rand7() - 1) * 7 + (rand7() - 1)
    if x >= 1 && x <= 10 {
        return x
    }
}
```
当 x∈[1,10]时返回 x ，否则重新计算

上面这种方法效率很低，因为我们只需要 [1, 10] 范围的整数，但会生成 [0, 48] 范围的整数，相当于有 4/5 的数字都是无用的，需要重新生成。
可不可以充分利用 [0, 48] 范围内尽可能多的数字呢？这样可以让 while 舍弃的数字比例更少，也就是让 while 重新执行的概率更低。

一种方法是选择 [1, 40] 范围里的数，通过取余运算来得到 [1, 10] 范围的数：
```go
x := (rand7() - 1) * 7 + (rand7() - 1) // 0 - 48
if x >= 1 && x <= 40 {
    return x % 10 + 1
}
```
这种方法只有 0、41、42、…、48 一共 9 个无用数字，运行时间从 24ms 降低至 16ms。

我们还可以进一步优化。对于上面这 9 个无用数字，计算 x % 40 可以得到 [0, 8] 范围的均匀随机整数。此时再调用一次 Rand7()，计算 (x % 40) * 7 + Rand7()，这相当于 Rand8() * 7 + Rand7()。显然，我们可以得到 [1, 63] 范围的均匀随机整数。这时 [1, 60] 范围里的数都可以用来作取余运算，只有 61、62、63 共 3 个无用数字：
```go
x = (x % 40) * 7 + rand7() // 1 - 63
if x <= 60 {
	return x % 10 + 1
}
```
这还不算完。对于 61、62、63，我们也可以用相同的思路，再调用一次 Rand7()，计算 (x - 61) * 7 + Rand7()，相当于 Rand2() * 7 + Rand7()，可以得到 [1, 21] 范围的均匀随机整数，这时再作取余运算，只有 1 个无用数字（21）：
```go
x = (x - 61) * 7 + rand7() // 1 - 21
if x <= 20 {
	return x % 10 + 1
}
```
运行时间从 16ms 降低至 8ms。每次 while 执行的时候，只有 1 个无用数字（21）会被舍弃，重新执行的概率很低。

## RandM 生成 RandN
已知 RandM() 可以等概率的生成 [0, M-1] 范围的随机整数，那么执行 k 次，每次都得到 M 进制的一位，可以等概率生成 [0,Mk−1]
范围的随机整数，记为 x
RandN 至少需要 N 个均匀随机整数，因此只需要取 k
，使得 Mk−1>=N
即可
此时有多种方式得到 RandN：
一种是只在 x∈[0,N−1]
时返回 x
另一种是利用取余运算，在保证等概率的前提下，尽可能多的利用生成的数字，从而减少舍弃的数字比例，降低 while 重复执行的概率