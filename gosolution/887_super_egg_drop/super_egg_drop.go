package main

/*
https://leetcode.cn/problems/super-egg-drop
给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。
如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

示例 1：

输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
示例 2：

输入：k = 2, n = 6
输出：3
示例 3：

输入：k = 3, n = 14
输出：4
*/
func superEggDrop(k int, n int) int {
	/*
		define:
			k：有k个鸡蛋
			m：扔m次
			dp[k][m]：支持查找的最高楼层数——这个楼层数，可以通过用k个鸡蛋，扔m次，并保证找到鸡蛋不碎的最高楼层f。

		原题：已知k个鸡蛋，n层楼，求最少扔多少次，一定能找到鸡蛋不碎的最高楼层f。
		转化：已知k个鸡蛋，扔m次，最多支持多少层楼的查找，一定能找到鸡蛋不碎的最高楼层f。

		比如有2个鸡蛋，100层楼,
		dp[2][14]=105，那如果我们又知道dp[2][13]=91 显然就有：
		∀正整数n∈[92,105]层，都有扔鸡蛋次数m=14
		对于给定鸡蛋数k和楼层数n，只需要找到满足条件 dp[k][m] >= n 的最小 m 值，即为所求的最少扔鸡蛋次数。

		从零开始拓展搜索边界的游戏——搜索楼层。dp[k][m]：支持查找的最高楼层数，就可以理解为：给定k、m，能搜索到的最大范围。

			搜索过程：

			第一步：
			在大楼中的任意某一层开始首次搜索，占1层，消耗了1次搜索次数（扔鸡蛋次数m--）。
			第二步：摔碎就下楼，没碎就上楼。
			摔碎：下楼搜索之下部分。
			没碎：上楼搜索之上部分。
			我们知道dp[k][m]是支持查找的最高楼层数，对标着可以理解为最大的搜索范围，注意这里显然要包含所有可能被搜索到的范围。

			我们知道： 总楼层数=之下楼层数+之上楼层数+1（本层）

			要使搜索范围最大，则之下搜索范围、之上搜索范围都应该最大，即对应的dp值，所以可以建立状态转移方程如下：

			dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
			按照上述的搜索流程，k个鸡蛋，扔m次，扔完第一次，可能上楼搜索，也可能下楼搜索。

			没碎，上楼搜索的最大可能搜索范围为dp[k][m-1]。（k个鸡蛋，还能扔m-1次）
			碎了，下楼搜索的最大可能搜索范围为dp[k-1][m-1]。（k-1个鸡蛋，还能扔m-1次）

	*/
	dp := make([][]int, k+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	m := 0
	for dp[k][m] < n {
		m++
		for i := 1; i <= k; i++ {
			dp[i][m] = dp[i][m-1] + dp[i-1][m-1] + 1
		}
	}
	return m
}
